
type Reader (
    read: (self, buf: [u8]) -> Result<usize>,
)

type Seeker (
    position: usize,
    seek: (self, pos: usize) -> Result<()>,
)

type NamedFile (
    name: String,
    ..Reader,
    ..Seeker,
)

type File (
    ..Reader, // contract we have to fulfill with impl blocks
    ..Seeker, 
)

type WindowsFile (
    handle: usize,
    ..File
)

type LinuxFile {
    handle: usize,
    ..File
}

impl File
    fn open = String -> Self
        Self.open (path: @, mode: OpenMode.Read)
    end

    fn create = String -> Self
        Self.open (path: @, mode: OpenMode.Write | OpenMode.Create | OpenMode.Truncate)
    end
end

impl WindowsFile
    fn open = (path: String, mode: OpenMode) -> Self
        // do platform-specific stuff
    end
end

// fulfilling our contract
impl Reader for File
    fn read = (self, buf: [u8]) -> Result<usize>
        @.inner_read buf
        Self.inner_read (@, buf)
    end
end

impl Seeker for File
    let position = 
end
